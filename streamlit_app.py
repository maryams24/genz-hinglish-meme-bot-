# Code Generated by Sidekick is for learning and experimentation purposes only.
import base64
import datetime as dt
import io
import math
import random
import re
import wave
from pathlib import Path

import streamlit as st
import streamlit.components.v1 as components

# =============================
# Page
# =============================
st.set_page_config(page_title="FAAH Roast Bot", page_icon="üéõÔ∏è", layout="centered")
random.seed()

# =============================
# Session state
# =============================
def ss_init():
    if "messages" not in st.session_state:
        st.session_state.messages = []

    if "faah_upload_bytes" not in st.session_state:
        st.session_state.faah_upload_bytes = None
        st.session_state.faah_upload_mime = None
        st.session_state.faah_upload_name = None

    if "pending_audio_bytes" not in st.session_state:
        st.session_state.pending_audio_bytes = None
        st.session_state.pending_audio_mime = None
        st.session_state.pending_audio_label = None
        st.session_state.pending_audio_autoplay = True
        st.session_state.audio_nonce = 0

    if "sound_enabled" not in st.session_state:
        st.session_state.sound_enabled = False

    if "sound_error_once" not in st.session_state:
        st.session_state.sound_error_once = False

    if "_queued_input" not in st.session_state:
        st.session_state._queued_input = None


ss_init()

# =============================
# Bright, colorful, aesthetic UI
# =============================
st.markdown(
    """
<style>
/* Code Generated by Sidekick is for learning and experimentation purposes only. */
:root{
  --line: rgba(187,189,191,0.18);
  --txt: rgba(255,255,255,0.92);
  --muted: rgba(255,255,255,0.72);
  --chip: rgba(255,255,255,0.06);
}
.stApp{
  background:
    radial-gradient(1100px 680px at 10% 5%, rgba(0,220,6,0.16), transparent 60%),
    radial-gradient(900px 520px at 92% 8%, rgba(0,169,224,0.20), transparent 62%),
    radial-gradient(900px 560px at 50% 98%, rgba(255,209,0,0.14), transparent 62%),
    radial-gradient(1000px 600px at 70% 70%, rgba(218,41,28,0.10), transparent 60%),
    linear-gradient(180deg, #05060A 0%, #0A0F16 55%, #05060A 100%);
}
.block-container{ padding-top: 1.15rem; max-width: 980px; }
.hero{
  border: 1px solid var(--line);
  background: linear-gradient(180deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.04) 100%);
  border-radius: 18px;
  padding: 16px 16px 12px 16px;
  backdrop-filter: blur(10px);
}
.title{
  font-size: 1.55rem;
  font-weight: 850;
  color: var(--txt);
  letter-spacing: 0.2px;
  margin: 0;
}
.sub{ margin-top: 6px; color: var(--muted); font-size: 0.95rem; }
.kbd{
  display:inline-block;
  padding: 2px 8px;
  border-radius: 8px;
  border: 1px solid var(--line);
  background: var(--chip);
  font-size: 0.84rem;
  margin-right: 6px;
}
.chips{ display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
.chip{
  border: 1px solid var(--line);
  background: var(--chip);
  padding: 7px 10px;
  border-radius: 999px;
  font-size: 0.86rem;
  color: var(--muted);
}
.card{
  margin-top: 12px;
  border: 1px solid var(--line);
  background: rgba(255,255,255,0.05);
  border-radius: 18px;
  padding: 12px 12px 6px 12px;
  backdrop-filter: blur(10px);
}
.small{ opacity: 0.80; font-size: 0.90rem; }
</style>
""",
    unsafe_allow_html=True,
)

# =============================
# Safety (lightweight)
# =============================
BLOCKLIST = {
    "rape", "raping", "nudes", "porn", "blowjob", "handjob", "kys", "kill yourself",
    "hitler", "nazi"
}
SAFE_REFUSAL = "I can‚Äôt help with abusive/explicit content. Keep it clean and I‚Äôm in."

def is_blocked(text: str) -> bool:
    t = (text or "").lower()
    if any(w in t for w in BLOCKLIST):
        return True
    return False

# =============================
# Audio: synth FAAH + queue + autoplay attempt
# =============================
def _to_wav_bytes(sr: int, samples_f32: list[float]) -> bytes:
    pcm = bytearray()
    for x in samples_f32:
        x = max(-1.0, min(1.0, float(x)))
        i = int(x * 32767.0)
        pcm += int(i).to_bytes(2, "little", signed=True)

    buf = io.BytesIO()
    with wave.open(buf, "wb") as wf:
        wf.setnchannels(1)
        wf.setsampwidth(2)
        wf.setframerate(sr)
        wf.writeframes(bytes(pcm))
    return buf.getvalue()

def make_faah_synth_wav() -> bytes:
    # Quick downward sweep + noise = ‚ÄúFAAH-ish‚Äù
    sr = 22050
    dur = 0.28
    n = int(sr * dur)
    out = []
    f0, f1 = 700.0, 140.0
    phase = 0.0
    for i in range(n):
        t = i / sr
        # exponential sweep
        freq = f0 * ((f1 / f0) ** (t / dur))
        phase += (2.0 * math.pi * freq) / sr
        sweep = math.sin(phase)
        noise = (random.random() * 2.0 - 1.0) * 0.10
        env = math.exp(-8.0 * t)
        y = math.tanh(2.3 * (0.90 * sweep + noise)) * env
        out.append(y)
    return _to_wav_bytes(sr, out)

def make_beep_wav() -> bytes:
    sr = 22050
    dur = 0.10
    n = int(sr * dur)
    out = []
    for i in range(n):
        t = i / sr
        env = math.exp(-10.0 * t)
        out.append(0.18 * math.sin(2.0 * math.pi * 880.0 * t) * env)
    return _to_wav_bytes(sr, out)

def load_assets_faah() -> tuple[bytes | None, str | None, str | None]:
    # Optional: put a file at assets/faah.mp3 (or .wav) in your repo
    candidates = [
        (Path("assets/faah.mp3"), "audio/mpeg"),
        (Path("assets/faah.wav"), "audio/wav"),
    ]
    for p, mime in candidates:
        if p.exists() and p.is_file():
            return p.read_bytes(), mime, str(p)
    return None, None, None

ASSET_BYTES, ASSET_MIME, ASSET_PATH = load_assets_faah()

def queue_audio(bytes_data: bytes, mime: str, label: str | None = None, autoplay: bool = True):
    st.session_state.pending_audio_bytes = bytes_data
    st.session_state.pending_audio_mime = mime
    st.session_state.pending_audio_label = label
    st.session_state.pending_audio_autoplay = autoplay
    st.session_state.audio_nonce += 1

def render_autoplay_audio(audio_bytes: bytes, mime: str, nonce: int):
    # Best-effort autoplay: browsers may still block without user gesture
    b64 = base64.b64encode(audio_bytes).decode("ascii")
    html = f"""
    <audio id="faah{nonce}" autoplay>
      <source src="data:{mime};base64,{b64}" type="{mime}">
    </audio>
    <script>
      (function(){{
        const el = document.getElementById("faah{nonce}");
        if(!el) return;
        const p = el.play();
        if(p && p.catch) p.catch(()=>{{}});
      }})();
    </script>
    """
    components.html(html, height=0, width=0)

DEFAULT_SOUND_ERROR = "SoundBlockedError: click ‚ÄòEnable Sound‚Äô once, then send again."

def get_faah_bytes(sound_mode: str) -> tuple[bytes, str, str]:
    if sound_mode == "FAAH (uploaded)" and st.session_state.faah_upload_bytes:
        return (
            st.session_state.faah_upload_bytes,
            st.session_state.faah_upload_mime or "audio/mpeg",
            "FAAH (uploaded)",
        )
    if sound_mode == "FAAH (assets)" and ASSET_BYTES:
        return (ASSET_BYTES, ASSET_MIME or "audio/mpeg", f"FAAH (assets: {ASSET_PATH})")
    # synth fallback
    return (make_faah_synth_wav(), "audio/wav", "FAAH (synth)")

# =============================
# Meme + banter engines
# =============================
VIBE_PRESETS = {
    "Office": {"roast": 0, "talk": 0.45, "hinglish": 0.05, "filmy": 0.05},
    "Bestie": {"roast": 2, "talk": 0.75, "hinglish": 0.60, "filmy": 0.30},
    "Filmy":  {"roast": 3, "talk": 0.80, "hinglish": 0.70, "filmy": 0.85},
    "Savage": {"roast": 7, "talk": 0.70, "hinglish": 0.55, "filmy": 0.20},
}

BANTER_OPENERS = [
    "Arrey sun.", "Haan bolo.", "Okay wait‚Äîfull context do.",
    "Noted. Slightly suspicious.", "Main sun raha‚Äîcontinue.",
]
BANTER_TAGS = [
    "*dramatic zoom-in*", "*group chat typing noises*",
    "*slow clap, fast judgment*", "*tension bgm on*",
]
HINGLISH_SPRINKLES = ["bhai", "yaar", "scene", "set", "pakka", "chill", "bas", "matlab"]

ROAST_LINES_LIGHT = [
    "Ye plan hai ya draft‚Äîbahut versions.",
    "‚ÄòOn my way‚Äô tum bolte ho ya tradition hai?",
    "Confidence 10/10, timing 2/10.",
]
ROAST_LINES_SAVAGE = [
    "Tu time pe aata hai bas excuses ke saath.",
    "Consistency consistent hai‚Äîat disappearing.",
    "Discipline left the chat. Twice.",
]

FOLLOWUP_QUESTIONS_FUN = [
    "One detail: who started it?",
    "Scale 1‚Äì10, kitna cooked?",
    "Exact line kya bola unhone?",
    "Give me time + place + villain.",
]
FOLLOWUP_QUESTIONS_OFFICE = [
    "What‚Äôs the desired outcome?",
    "Any constraints or deadlines?",
    "Who‚Äôs the audience/stakeholder?",
]

NEXT_ACTION_SUGGESTIONS = [
    "Want a POV meme? Type: /meme pov <line>",
    "Want Bollywood drama? Type: /meme bolly <line>",
    "Want an IG caption? Type: /caption <line>",
    "Want formats? Type: /ig prompts",
    "Want FAAH? Type: /faah",
]

BOLLY_STYLES = [
    "Overacting level: 100",
    "Dialogues mode: ON, logic: OFF",
    "Slow zoom reaction + ‚Äòabey yaar‚Äô",
    "Auntie network breaking news vibe",
]

MEME_FORMATS = {
    "pov": [
        "POV: {setup}\nText: ‚Äúwhy am I like this‚Äù\nCut to: {payoff}",
        "POV: {setup}\nMe (internally): ‚Äúchill‚Äù\nAlso me: {payoff}",
    ],
    "microdrama": [
        "Hook: {setup}\nTwist: {payoff}\nCTA: ‚Äòcomment your version‚Äô",
        "Hook: {setup}\nEscalation: {payoff}\nCTA: ‚Äòsend this to your friend‚Äô",
    ],
    "invsout": [
        "IN: {setup}\nOUT: {payoff}",
        "IN: {setup}\nOUT: {payoff}\nNo cap.",
    ],
    "thisvsthat": [
        "This: {setup}\nThat: {payoff}",
        "{setup} vs {payoff}\nChoose your fighter.",
    ],
    "greenscreen": [
        "Green screen: {setup}\nMe: ‚Äúlet‚Äôs unpack this‚Äù\nAlso me: {payoff}",
        "Green screen: {setup}\nMy face says it all.\n{payoff}",
    ],
    "capcut": [
        "CapCut-template vibes:\nClip 1: {setup}\nBeat drop: {payoff}\nEnd: ‚Äòsave for later‚Äô",
        "Fast cuts + on-beat text:\n{setup}\n{payoff}\nLoop it.",
    ],
    "aitokyo": [
        "AI scene replace:\nSwap main character with: {setup}\nPlot twist: {payoff}",
        "Replace the ‚Äòhero‚Äô with: {setup}\nReplace the ‚Äòtwist‚Äô with: {payoff}",
    ],
    "bolly": [
        "Bollywood energy: {style}\nScene: {setup}\nReaction: {payoff}",
        "Filmy zoom-in:\n{style}\n{setup}\n{payoff}",
    ],
}

TOPIC_FILLERS = {
    "work": (["Client: ‚Äòsmall change‚Äô", "Manager: ‚Äòquick update?‚Äô", "Calendar: 9 calls back-to-back"],
             ["Deadline jump-scare", "PPT is my personality now", "My soul left the call"]),
    "social": (["Soft launch subtle plan", "Caption ‚Äòsimple sa‚Äô", "Story ‚Äòlowkey‚Äô"],
               ["17 drafts", "Delete ‚Üí repost cycle", "Close friends chaos"]),
    "study": (["‚ÄòBas 20 mins padhai‚Äô", "Exam se 1 din pehle confidence", "Notes open = motivation 0"],
              ["3 tabs + 0 pages", "All-nighter delulu", "Aesthetic notes, tragic marks"]),
    "food": (["‚ÄòBas ek bite‚Äô", "Extra spicy choose", "Food app ‚Äòsirf dekhne‚Äô"],
             ["Extra cheese + regret", "UPI pin speedrun", "Instant consequences"]),
    "general": (["Main character moment", "‚ÄòBas ek kaam‚Äô", "Life ka plan"],
                ["Plot twist unlocked", "Aura points -10", "Chalta hai cope mode"]),
}

def detect_topic(text: str) -> str:
    t = (text or "").lower()
    if any(w in t for w in ["client", "manager", "meeting", "deadline", "ppt", "deck", "standup", "call"]):
        return "work"
    if any(w in t for w in ["reel", "reels", "ig", "instagram", "story", "post", "caption"]):
        return "social"
    if any(w in t for w in ["exam", "study", "college", "class", "assignment"]):
        return "study"
    if any(w in t for w in ["momos", "chai", "coffee", "pizza", "spicy", "food"]):
        return "food"
    return "general"

def pick_setup_payoff(topic: str, core: str) -> tuple[str, str]:
    topic = topic if topic in TOPIC_FILLERS else "general"
    setups, payoffs = TOPIC_FILLERS[topic]
    setup = re.sub(r"\s+", " ", (core or "")).strip() or random.choice(setups)
    payoff = random.choice(payoffs)
    return setup, payoff

def make_meme(fmt: str, core: str) -> str:
    topic = detect_topic(core)
    setup, payoff = pick_setup_payoff(topic, core)
    fmt = (fmt or "pov").lower().strip()
    if fmt not in MEME_FORMATS:
        fmt = "pov"
    template = random.choice(MEME_FORMATS[fmt])
    if fmt == "bolly":
        return template.format(style=random.choice(BOLLY_STYLES), setup=setup, payoff=payoff)
    return template.format(setup=setup, payoff=payoff)

def make_caption(core: str) -> str:
    topic = detect_topic(core)
    hooks = ["POV:", "Me:", "Lowkey", "Highkey", "Normalize", "It‚Äôs giving"]
    specifics = ["at 2:13am", "with 3% battery", "after one chai", "during exam week", "in the group chat"]
    cta = ["Real or nah.", "IYKYK.", "Be honest.", "Tell me I‚Äôm not alone."]
    core = re.sub(r"\s+", " ", (core or "")).strip() or "this whole situation"
    core = core[:120]
    tags = {
        "work": "#workmemes #officehumor #consultinglife",
        "social": "#reels #memes #captionideas",
        "study": "#studentlife #examseason #studygram",
        "food": "#foodie #snacktime #streetfood",
        "general": "#relatable #memes #vibes",
    }[topic]
    return f"{random.choice(hooks)} {core} {random.choice(specifics)} {random.choice(cta)}\n{tags}"

IG_PROMPTS = (
    "Copy‚Äëpaste prompts:\n"
    "- /meme pov I said ‚Äòon my way‚Äô\n"
    "- /meme microdrama client said ‚Äòsmall change‚Äô\n"
    "- /meme invsout college life\n"
    "- /meme thisvsthat gym vs sleep\n"
    "- /meme greenscreen group chat drama\n"
    "- /meme capcut weekend recap\n"
    "- /meme aitokyo meeting reschedule\n"
    "- /meme bolly when chai finishes\n"
)

def sprinkle_hinglish(text: str, ratio: float) -> str:
    if ratio <= 0:
        return text
    if random.random() < ratio:
        text = f"{random.choice(HINGLISH_SPRINKLES)} ‚Äî {text}"
    if random.random() < ratio * 0.6:
        text = f"{text} ({random.choice(HINGLISH_SPRINKLES)})"
    return text

def pick_roast(roast_level: int) -> str:
    if roast_level <= 0:
        return ""
    pool = ROAST_LINES_LIGHT if roast_level <= 4 else ROAST_LINES_SAVAGE
    return random.choice(pool)

def make_talkative_reply(base_reply: str, user_text: str, office_mode: bool, allow_roasts: bool,
                         roast_level: int, talk: float, hinglish: float, filmy: float) -> tuple[str, bool]:
    low = (user_text or "").strip().lower()

    # Don‚Äôt overtalk pure command outputs
    if low.startswith(("/help", "/ig", "/slang", "/hindi")):
        return base_reply, False

    parts = []
    used_roast = False

    # opener
    if random.random() < talk:
        parts.append(random.choice(BANTER_OPENERS))

    # tag (less in office)
    tag_prob = (0.08 if office_mode else (0.25 + 0.55 * filmy))
    if random.random() < tag_prob:
        parts.append(random.choice(BANTER_TAGS))

    # roast (only if allowed + not office mode)
    if allow_roasts and (not office_mode) and roast_level > 0:
        r = pick_roast(roast_level)
        if r and random.random() < (0.30 + 0.07 * roast_level):
            parts.append(r)
            used_roast = True

    parts.append(base_reply)

    # follow-up
    if random.random() < (0.35 + 0.40 * talk):
        q = random.choice(FOLLOWUP_QUESTIONS_OFFICE if office_mode else FOLLOWUP_QUESTIONS_FUN)
        parts.append(q)

    # next suggestion (keep but more subtle in office)
    if random.random() < (0.55 if office_mode else 0.85):
        parts.append(random.choice(NEXT_ACTION_SUGGESTIONS))

    out = "\n".join([p for p in parts if p])
    if office_mode:
        out = out.replace("Arrey", "Hey").replace("bhai", "hey").replace("yaar", "hey")
        out = re.sub(r"\s+\((bhai|yaar|scene|set|pakka|chill|bas|matlab)\)", "", out, flags=re.I)

    out = sprinkle_hinglish(out, 0.0 if office_mode else hinglish)
    return out, used_roast

# =============================
# Office conversation (normal work talk)
# =============================
def office_reply(user_text: str) -> str:
    t = (user_text or "").strip()
    low = t.lower()
    topic = detect_topic(t)

    if any(k in low for k in ["status", "update", "standup"]):
        return "Got it. Share: what‚Äôs done, what‚Äôs next, and any blockers. If you paste your bullets, I‚Äôll tighten them."
    if any(k in low for k in ["email", "message", "slack", "teams"]):
        return "Tell me: audience + ask + deadline. I‚Äôll draft a crisp message."
    if any(k in low for k in ["ppt", "deck", "slides"]):
        return "What‚Äôs the audience and decision needed? I can propose a 5‚Äì8 slide storyline."
    if topic == "work":
        return "Understood. What‚Äôs the goal, the constraint (time/approval), and the next decision you need?"
    return "I‚Äôm with you. If you describe the situation in one line, I‚Äôll respond in a professional, helpful way."

# =============================
# Command router
# =============================
def bot_reply(user_text: str) -> tuple[str, bool]:
    """
    returns (reply_text, must_play_faah)
    must_play_faah is True only for /faah or explicit 'faah' keyword
    (roast sound is handled separately)
    """
    t = (user_text or "").strip()
    low = t.lower()

    if low in ("/help", "help"):
        return (
            "Commands:\n"
            "- /faah  (play FAAH)\n"
            "- /meme <pov|microdrama|invsout|thisvsthat|greenscreen|capcut|aitokyo|bolly> <text>\n"
            "- /caption <text>\n"
            "- /ig prompts\n\n"
            "Examples:\n"
            "- /faah\n"
            "- /meme pov I said ‚Äòon my way‚Äô\n"
            "- /meme microdrama client said ‚Äòsmall change‚Äô\n"
            "- /meme bolly when chai finishes\n",
            False,
        )

    if low.startswith("/ig"):
        return (IG_PROMPTS, False)

    if low.startswith("/caption"):
        core = t[len("/caption"):].strip()
        return (make_caption(core), False)

    if low.startswith("/meme"):
        rest = t[len("/meme"):].strip()
        parts = rest.split(maxsplit=1)
        fmt = parts[0].lower() if parts else "pov"
        core = parts[1] if len(parts) > 1 else ""
        return (make_meme(fmt, core), (" faah" in f" {low}"))

    if low.startswith("/faah"):
        return ("FAAH triggered.", True)

    # Default: no forced FAAH
    return ("", False)

# =============================
# Sidebar
# =============================
with st.sidebar:
    st.subheader("Sound")
    sound_mode = st.radio("FAAH source", ["Off", "FAAH (uploaded)", "FAAH (assets)", "FAAH (synth)"], index=1)
    attempt_autoplay = st.toggle("Attempt autoplay", value=True)
    error_text = st.text_input("One-time sound error text", value=DEFAULT_SOUND_ERROR)

    c1, c2 = st.columns(2)
    with c1:
        if st.button("Enable Sound (click once)"):
            st.session_state.sound_enabled = True
            st.success("Enabled. Autoplay will be attempted.")
    with c2:
        if st.button("Reset sound error"):
            st.session_state.sound_error_once = False
            st.info("Will show once again.")

    if sound_mode == "FAAH (uploaded)":
        up = st.file_uploader("Upload faah.mp3 or faah.wav", type=["mp3", "wav"])
        if up is not None:
            st.session_state.faah_upload_bytes = up.getvalue()
            st.session_state.faah_upload_name = up.name
            st.session_state.faah_upload_mime = up.type or ("audio/mpeg" if up.name.lower().endswith(".mp3") else "audio/wav")
        if st.session_state.faah_upload_name:
            st.caption(f"Loaded: {st.session_state.faah_upload_name}")
        if st.button("Preview FAAH upload"):
            if st.session_state.faah_upload_bytes:
                st.audio(st.session_state.faah_upload_bytes, format=st.session_state.faah_upload_mime or "audio/mpeg")
            else:
                st.warning("Upload first.")

    if sound_mode == "FAAH (assets)":
        if ASSET_BYTES:
            st.caption(f"Loaded from repo: {ASSET_PATH}")
            if st.button("Preview assets FAAH"):
                st.audio(ASSET_BYTES, format=ASSET_MIME or "audio/mpeg")
        else:
            st.warning("Not found: assets/faah.mp3 (or faah.wav).")

    st.divider()
    st.subheader("Bot")
    vibe = st.selectbox("Personality", list(VIBE_PRESETS.keys()), index=0)
    preset = VIBE_PRESETS[vibe]

    office_mode = st.toggle("Office mode (normal work convo)", value=(vibe == "Office"))
    allow_roasts = st.toggle("Allow roasts (FAAH plays on roast)", value=(vibe in ("Bestie", "Filmy", "Savage")))

    talk = st.slider("Talkativeness", 0.0, 1.0, float(preset["talk"]), 0.05)
    roast_level = st.slider("Roast level", 0, 10, int(preset["roast"]), 1)
    hinglish = st.slider("Hinglish mix", 0.0, 1.0, float(preset["hinglish"]), 0.05)
    filmy = st.slider("Filmy drama", 0.0, 1.0, float(preset["filmy"]), 0.05)

    st.divider()
    st.subheader("Quick buttons")
    if st.button("Play FAAH now"):
        st.session_state._queued_input = "/faah"
    if st.button("Roast me (FAAH)"):
        st.session_state._queued_input = "roast me for being late again"
    if st.button("Office: draft a status update"):
        st.session_state._queued_input = "help me write a standup update"
    if st.button("Meme: client ‚Äòsmall change‚Äô"):
        st.session_state._queued_input = "/meme microdrama client said small change"
    if st.button("IG prompts"):
        st.session_state._queued_input = "/ig prompts"

# =============================
# Hero
# =============================
st.markdown(
    """
<div class="hero">
  <div class="title">FAAH Roast Bot ‚Ä¢ Fun + Office Mode</div>
  <div class="sub">
    <span class="kbd">/faah</span>
    <span class="kbd">/meme</span>
    <span class="kbd">/caption</span>
    <span class="kbd">/ig prompts</span>
    <span class="kbd">/help</span>
    <span class="kbd">Type ‚Äúroast me‚Äù</span>
  </div>
  <div class="chips">
    <div class="chip">FAAH plays only on roasts (and /faah)</div>
    <div class="chip">Office mode = professional replies</div>
    <div class="chip">Try: /meme bolly when chai finishes</div>
    <div class="chip">Try: help me write a standup update</div>
  </div>
</div>
""",
    unsafe_allow_html=True,
)

# =============================
# Audio render (attempt autoplay + fallback player)
# =============================
if st.session_state.pending_audio_bytes is not None:
    if st.session_state.pending_audio_label:
        st.caption(st.session_state.pending_audio_label)

    mime = st.session_state.pending_audio_mime or "audio/mpeg"

    if attempt_autoplay and st.session_state.pending_audio_autoplay and st.session_state.sound_enabled:
        render_autoplay_audio(st.session_state.pending_audio_bytes, mime, st.session_state.audio_nonce)

    st.audio(st.session_state.pending_audio_bytes, format=mime)

    st.session_state.pending_audio_bytes = None
    st.session_state.pending_audio_mime = None
    st.session_state.pending_audio_label = None
    st.session_state.pending_audio_autoplay = True

# =============================
# Chat UI
# =============================
st.markdown('<div class="card">', unsafe_allow_html=True)
st.markdown('<div class="small">Type anything. Office mode answers normally; fun mode banters. FAAH plays on roasts.</div>', unsafe_allow_html=True)

for m in st.session_state.messages:
    with st.chat_message(m["role"]):
        st.markdown(m["content"])
        st.markdown(f'<div class="small">{m["ts"]}</div>', unsafe_allow_html=True)

queued = st.session_state._queued_input
if queued:
    st.session_state._queued_input = None

user_text = queued or st.chat_input("Type here‚Ä¶ (try: /faah or ‚Äòroast me‚Äô)")

st.markdown("</div>", unsafe_allow_html=True)

# =============================
# Handle message
# =============================
if user_text:
    ts = dt.datetime.now().strftime("%H:%M")
    st.session_state.messages.append({"role": "user", "content": user_text, "ts": ts})

    if is_blocked(user_text):
        st.session_state.messages.append({"role": "assistant", "content": SAFE_REFUSAL, "ts": ts})
        queue_audio(make_beep_wav(), "audio/wav", label="Beep", autoplay=False)
        st.rerun()

    # 1) commands first
    reply, must_play_faah = bot_reply(user_text)

    # 2) if not a command, choose office vs fun
    if not reply:
        if office_mode:
            reply = office_reply(user_text)
        else:
            # fun default: gently steer to memes if they want
            topic = detect_topic(user_text)
            if "meme" in user_text.lower() or "reel" in user_text.lower():
                reply = "Say less. Want POV, bolly, or microdrama? (Try: /ig prompts)"
            elif topic == "work":
                reply = "Office chaos detected. Give me the exact line they said‚ÄîI'll meme it or make it professional."
            else:
                reply = "Okay, I‚Äôm listening. Give me the one-liner version‚Äîthen I‚Äôll cook."

    # 3) Banter layer + detect roast usage
    full_reply, used_roast = make_talkative_reply(
        reply,
        user_text,
        office_mode=office_mode,
        allow_roasts=allow_roasts,
        roast_level=roast_level,
        talk=talk,
        hinglish=hinglish,
        filmy=filmy,
    )

    # 4) Decide sound: ONLY for roasts (plus /faah / explicit faah)
    should_play_sound = False
    if sound_mode != "Off":
        if must_play_faah:
            should_play_sound = True
        elif used_roast:
            should_play_sound = True

    if should_play_sound and sound_mode != "Off":
        if attempt_autoplay and (not st.session_state.sound_enabled) and (not st.session_state.sound_error_once):
            st.session_state.sound_error_once = True
            st.error(error_text or DEFAULT_SOUND_ERROR)

        b, m, label = get_faah_bytes(sound_mode)
        queue_audio(b, m, label=label, autoplay=attempt_autoplay)

    st.session_state.messages.append({"role": "assistant", "content": full_reply, "ts": ts})
    st.rerun()
