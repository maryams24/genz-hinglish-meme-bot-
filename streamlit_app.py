# Code Generated by Sidekick is for learning and experimentation purposes only.
import re
import io
import wave
import random
import datetime as dt

import numpy as np
import streamlit as st
from better_profanity import profanity

# -----------------------------
# Setup
# -----------------------------
profanity.load_censor_words()
random.seed()

st.set_page_config(page_title="Gen‑Z Hinglish Meme Bot", layout="centered")

st.markdown(
    """
<style>
/* Code Generated by Sidekick is for learning and experimentation purposes only. */
.stApp {
  background: radial-gradient(1200px 600px at 20% 10%, rgba(0,124,176,0.35), transparent 55%),
              radial-gradient(1000px 500px at 80% 0%, rgba(134,188,37,0.25), transparent 60%),
              radial-gradient(900px 450px at 50% 90%, rgba(237,139,0,0.18), transparent 60%),
              linear-gradient(180deg, #070A0F 0%, #0B0F14 55%, #070A0F 100%);
}
.block-container { padding-top: 2.2rem; }
.chat-card {
  border: 1px solid rgba(187,189,191,0.22);
  background: rgba(18,26,36,0.55);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 14px 14px 6px 14px;
}
.small { opacity: 0.82; font-size: 0.92rem; }
kbd { background: rgba(255,255,255,0.08); padding: 2px 6px; border-radius: 6px; }
</style>
""",
    unsafe_allow_html=True,
)

# -----------------------------
# Safety (clean-only)
# -----------------------------
ABUSIVE_PATTERNS = [
    r"\b(kill yourself|kys)\b",
    r"\b(i will kill|i'll kill)\b",
    r"\b(rape|raping)\b",
    r"\b(nazi)\b",
    r"\b(hate you|die)\b",
]
SEXUAL_EXPLICIT_PATTERNS = [
    r"\b(blowjob|handjob|porn|nudes|sex chat)\b",
]
SAFE_REFUSAL = "I can’t help with abusive/explicit content. Say it cleanly and I’ll help."

def is_blocked(text: str) -> bool:
    t = text.lower()
    if profanity.contains_profanity(t):
        return True
    for pat in ABUSIVE_PATTERNS + SEXUAL_EXPLICIT_PATTERNS:
        if re.search(pat, t, flags=re.I):
            return True
    return False

# -----------------------------
# Audio helpers (WAV bytes)
# -----------------------------
def _to_wav_bytes(sr: int, y: np.ndarray) -> bytes:
    y = np.clip(y, -1.0, 1.0)
    pcm = (y * 32767.0).astype(np.int16)
    buf = io.BytesIO()
    with wave.open(buf, "wb") as wf:
        wf.setnchannels(1)
        wf.setsampwidth(2)
        wf.setframerate(sr)
        wf.writeframes(pcm.tobytes())
    return buf.getvalue()

def make_beep_wav() -> bytes:
    sr = 22050
    dur = 0.10
    t = np.linspace(0, dur, int(sr * dur), endpoint=False)
    y = 0.12 * np.sin(2 * np.pi * 880 * t)
    return _to_wav_bytes(sr, y.astype(np.float32))

def make_faah_synth_wav() -> bytes:
    """
    Synthetic “FAAH-ish” reaction: quick downward sweep + noise.
    This is NOT a real clip and does not imitate a specific person.
    """
    sr = 22050
    dur = 0.28
    t = np.linspace(0, dur, int(sr * dur), endpoint=False)

    f0, f1 = 650, 170
    freq = f0 * (f1 / f0) ** (t / dur)
    phase = 2 * np.pi * np.cumsum(freq) / sr
    sweep = np.sin(phase).astype(np.float32)

    noise = (np.random.randn(len(t)).astype(np.float32)) * 0.08
    env = np.exp(-8 * t).astype(np.float32)

    y = (0.9 * sweep + noise) * env
    y = np.tanh(2.2 * y).astype(np.float32)
    return _to_wav_bytes(sr, y)

# -----------------------------
# Hinglish + slang
# -----------------------------
HINGLISH_PHRASES = {
    "kya scene": "What’s the plan / what’s going on?",
    "scene kya hai": "What’s the status?",
    "kya chal raha": "What’s up?",
    "kya haal": "How are things?",
    "chill maar": "Relax / don’t stress.",
    "set hai": "Confirmed / fixed.",
    "kal set": "Let’s do it tomorrow.",
    "jugaad": "Quick workaround / hack.",
    "chalta hai": "It’s fine / let it slide.",
    "timepass": "Killing time / low-stakes fun.",
    "bhai": "Bro (friendly).",
    "yaar": "Mate/friend (friendly).",
}

GENZ_SLANG = {
    "aura": "Your vibe/energy; ‘aura points’ = cool points.",
    "cooked": "Exhausted / overwhelmed / done for.",
    "brainrot": "Scroll-fried meme-brain vibe.",
    "delulu": "Playfully delusional (optimistic coping).",
    "rizz": "Charisma / flirting skill.",
    "cap": "Lie/exaggeration. ‘No cap’ = for real.",
    "bet": "Okay / agreed / say less.",
    "mid": "Mediocre.",
    "tea": "Gossip / truth / info.",
    "yap": "Talk a lot (playful).",
    "ick": "A small turn-off that ruins the vibe.",
    "soft launch": "Subtle relationship hint, not official.",
    "hard launch": "Official relationship reveal post.",
    "crash out": "Lose patience / snap / go off (often joking).",
    "npc": "On autopilot; background-character energy.",
    "ate": "Did great / nailed it.",
    "rent free": "Stuck in your head constantly.",
}

def slang_lookup(term: str) -> str:
    key = term.strip().lower()
    if not key:
        return "Use: /slang <word>  (e.g., /slang cooked)"
    if key in GENZ_SLANG:
        return f"{key}: {GENZ_SLANG[key]}"
    if key in ("no cap", "nocap"):
        return "no cap: For real / not lying."
    return "Not in my slang list yet—try another word."

def hinglish_lookup(term: str) -> str:
    key = term.strip().lower()
    if not key:
        return "Use: /hindi <phrase>  (e.g., /hindi kya scene)"
    hits = [(k, v) for k, v in HINGLISH_PHRASES.items() if key in k]
    if not hits:
        return "Not found—try shorter (e.g., ‘scene’, ‘set’, ‘jugaad’)."
    return "\n".join([f"{k}: {v}" for k, v in hits[:15]])

# -----------------------------
# Topic detection
# -----------------------------
TOPIC_KEYS = {
    "plans": {"plan","weekend","tomorrow","today","hangout","meet","movie","cafe","party"},
    "relationships": {"crush","date","dating","ghost","seen","reply","situationship","relationship","texting"},
    "study": {"exam","test","assignment","class","study","notes","college","school"},
    "food": {"momos","chai","coffee","pizza","burger","snack","craving","food","spicy"},
    "gym": {"gym","workout","protein","leg","cardio","training"},
    "social": {"reel","reels","story","post","caption","soft","hard","launch","instagram","ig"},
    "gaming": {"game","rank","match","lag","carry","win","lose","gg"},
    "mood": {"sad","tired","stressed","anxious","overthinking","burnt","low","happy"},
}

def detect_topic(text: str) -> str:
    tokens = set(re.findall(r"[a-z']+", text.lower()))
    best = ("general", 0)
    for topic, keys in TOPIC_KEYS.items():
        score = len(tokens & keys)
        if score > best[1]:
            best = (topic, score)
    return best[0]

# -----------------------------
# Hashtags + captions
# -----------------------------
def hashtags(topic: str) -> str:
    base = {
        "plans": ["#weekendplans", "#friends", "#hangout"],
        "relationships": ["#situationship", "#texting", "#iykyk"],
        "study": ["#studentlife", "#examseason", "#studygram"],
        "food": ["#foodie", "#snacktime", "#streetfood"],
        "gym": ["#gymarc", "#fitness", "#legday"],
        "social": ["#reels", "#memes", "#captionideas"],
        "gaming": ["#gaming", "#ranked", "#gg"],
        "mood": ["#mood", "#relatable", "#selfcare"],
        "general": ["#relatable", "#memes", "#vibes"],
    }
    return " ".join(base.get(topic, base["general"])[:5])

def make_caption(core: str, topic: str) -> str:
    hooks = ["POV:", "Me:", "Lowkey", "Highkey", "It’s giving", "Normalize"]
    specifics = ["at 2:13am", "with 3% battery", "after one chai", "during exam week", "in the group chat"]
    prompts = ["Real or nah.", "IYKYK.", "Be honest.", "Tell me I’m not alone."]
    core = re.sub(r"\s+", " ", core).strip()
    core = core[:90] if core else "this whole situation"
    return f"{random.choice(hooks)} {core} {random.choice(specifics)} {random.choice(prompts)}\n{hashtags(topic)}"

# -----------------------------
# Meme templates by topic
# -----------------------------
MEME_TEMPLATES = {
    "two_panel": [
        "Me: {setup}\nAlso me: {payoff}",
        "{setup}\n—cut to me—\n{payoff}",
        "Expectation: {setup}\nReality: {payoff}",
    ],
    "drake": [
        "Drake: ❌ {setup}\nDrake: ✅ {payoff}",
        "Not it: {setup}\nIt: {payoff}",
    ],
    "office": [
        "Manager: “Quick update?”\nMe: {setup}\nAlso me: {payoff}",
        "Me in the standup: {setup}\nMe after standup: {payoff}",
    ],
    "brainrot": [
        "My brain at 3am: {setup}\nMy brain at 3:01am: {payoff}",
        "I open the app for 2 mins: {setup}\n45 mins later: {payoff}",
    ],
}

TOPIC_FILLERS = {
    "plans": {
        "setups": ["‘Aaj bas early night’ bolna", "‘Kal pakka time pe’ kehna", "‘Just one drink’ promise karna"],
        "payoffs": ["2am tak ‘one last place’ chalna", "‘Location bhej’ pe 47 mins lagna", "Morning me ‘bro I’m cooked’ text aana"],
    },
    "relationships": {
        "setups": ["‘I’m not attached’ bolna", "‘I’ll reply in 5 mins’ sochna", "‘Seen’ ko ignore karne ka plan"],
        "payoffs": ["3 hours me ‘why am I like this’ spiral", "‘Good night’ ke baad 12 reels bhejna", "‘We should talk’ drop kar dena"],
    },
    "study": {
        "setups": ["‘Bas 20 mins padhai’ bolna", "Notes open karte hi motivation", "Exam se 1 din pehle confidence"],
        "payoffs": ["3 tabs + 0 pages done", "Highlighter se aesthetic, marks se tragic", "‘All nighter’ ka delulu plan"],
    },
    "food": {
        "setups": ["‘Diet start Monday’ bolna", "‘Bas ek bite’ kehna", "Food app open karna ‘sirf dekhne’"],
        "payoffs": ["Extra cheese + extra regret", "Momos pe ‘extra spicy’ choose karna", "UPI pin enter speedrun"],
    },
    "gym": {
        "setups": ["‘Aaj leg day’ commitment", "Protein shake ka influencer arc", "Warm-up ke baad confidence"],
        "payoffs": ["DOMS me stairs enemy ban jana", "Gym me 5 mins, selfie me 50 mins", "‘Kal pakka’ loop restart"],
    },
    "social": {
        "setups": ["Caption sochna ‘simple sa’", "‘Soft launch’ ka subtle plan", "Story post karna ‘lowkey’"],
        "payoffs": ["Caption me 17 drafts", "Close friends me chaos", "Delete → repost → delete cycle"],
    },
    "gaming": {
        "setups": ["‘Last match’ bolna", "Ranked queue me confidence", "Ping ‘stable’ dekh ke khushi"],
        "payoffs": ["‘One more’ till sunrise", "Team: *yap* | Me: *carry* | Result: L", "Lag spike = villain origin"],
    },
    "mood": {
        "setups": ["‘I’m fine’ bolna", "‘Aaj productive day’ plan", "Overthinking ko ‘analysis’ bolna"],
        "payoffs": ["Bed + doomscroll combo", "To-do list: 12 items | Done: 1 vibe check", "Brain: *FAAH* (instant worry)"],
    },
    "general": {
        "setups": ["Life ka plan", "Main character moment", "‘Bas ek kaam’ sochna"],
        "payoffs": ["Plot twist unlocked", "Aura points -10", "‘Chalta hai’ cope mode"],
    },
}

def pick_template_key(user_choice: str) -> str:
    user_choice = (user_choice or "").strip().lower()
    aliases = {
        "2": "two_panel", "two": "two_panel", "two_panel": "two_panel",
        "drake": "drake",
        "office": "office", "work": "office",
        "brainrot": "brainrot", "scroll": "brainrot",
    }
    return aliases.get(user_choice, "")

def make_topic_meme(topic: str, core: str, template_key: str = "") -> str:
    topic = topic if topic in TOPIC_FILLERS else "general"
    setup_pool = TOPIC_FILLERS[topic]["setups"]
    payoff_pool = TOPIC_FILLERS[topic]["payoffs"]

    setup = core.strip() if core.strip() else random.choice(setup_pool)
    payoff = random.choice(payoff_pool)

    key = template_key if template_key in MEME_TEMPLATES else random.choice(list(MEME_TEMPLATES.keys()))
    fmt = random.choice(MEME_TEMPLATES[key])
    return f"Topic: {topic} | Template: {key}\n" + fmt.format(setup=setup, payoff=payoff)

# -----------------------------
# FAAH meme text
# -----------------------------
def make_faah_meme_text(core: str) -> str:
    core = re.sub(r"\s+", " ", core).strip() or "I try a tiny shortcut"
    setups = [f"Me: {core}", f"POV: {core}", f"When {core}"]
    payoff = random.choice([
        "Reality: *FAAAH* (instant consequences)",
        "Universe: *FAAH* (same-day delivery)",
        "My luck: *FAAH* (plot twist unlocked)",
    ])
    return f"{random.choice(setups)}\n{payoff}"

# -----------------------------
# Instagram “trends pack” (manual update)
# -----------------------------
IG_TRENDS_LAST_UPDATED = "2026-02-28"
IG_TRENDS_PACK = {
    "reels": [
        "Reels drive discovery; optimize for saves/shares/DMs.",
        "Hook fast (first ~1–2 seconds) with on-screen text.",
        "Micro-storytelling + education + BTS authenticity works well.",
        "Use trending audio where it fits; still make it sound-off friendly.",
        "Specific POV/day-in-the-life beats generic formats.",
    ],
    "content_ideas": [
        "POV: ‘Things I wish I knew before…’",
        "Micro-drama: expectation vs reality with a twist.",
        "Teach 1 thing in 20 seconds: 3 steps + 1 mistake.",
        "BTS: drafts, fails, bloopers, setup.",
        "Before/after + the one change that mattered.",
    ],
    "seo_keywords": [
        "Use keywords in caption text (not only hashtags).",
        "Add alt text for clarity/discoverability.",
    ],
    "hashtag_guidelines": [
        "Use fewer, more relevant hashtags (quality > quantity).",
        "Rule-of-thumb: 3–8 Reels, 5–10 carousels, 8–12 static posts.",
    ],
    "meme_notes": [
        "Video memes often outperform static because replay/pause matters.",
        "Classic templates cycle back—keep the caption ultra-specific.",
    ],
    "genz_slang_2026": [
        "aura, crash out, cooked, delulu, rizz, brainrot, NPC, soft/hard launch, no cap, W/L, mid, tea, yap",
    ],
}

def format_ig_pack(section: str) -> str:
    section = section.lower().strip()
    if section in ("trends", "all", ""):
        blocks = []
        for k in ("reels", "content_ideas", "seo_keywords", "hashtag_guidelines", "meme_notes", "genz_slang_2026"):
            blocks.append(f"IG {k.replace('_',' ').title()} (as of {IG_TRENDS_LAST_UPDATED}):\n- " + "\n- ".join(IG_TRENDS_PACK[k]))
        blocks.append("Note: Update this pack in GitHub to keep it fresh.")
        return "\n\n".join(blocks)
    if section in IG_TRENDS_PACK:
        return f"IG {section.replace('_',' ').title()} (as of {IG_TRENDS_LAST_UPDATED}):\n- " + "\n- ".join(IG_TRENDS_PACK[section])
    return "Use: /ig trends | /ig reels | /ig content_ideas | /ig seo_keywords | /ig hashtag_guidelines | /ig meme_notes | /ig genz_slang_2026"

# -----------------------------
# FAAH-on-jokes heuristic
# -----------------------------
JOKE_HINTS = {
    "pov", "expectation", "reality", "plot twist", "iykyk", "meme", "caption",
    "aura points", "cooked", "brainrot", "delulu", "rizz", "w", "l",
    "normalize", "cut to", "also me", "drake:", "standup", "group chat"
}

def is_jokey(user_text: str, bot_text: str) -> bool:
    ut = (user_text or "").strip().lower()
    bt = (bot_text or "").strip().lower()
    if ut.startswith(("/meme", "/caption")):
        return True
    t = f"{ut} {bt}"
    return any(h in t for h in JOKE_HINTS)

# -----------------------------
# Bot reply
# -----------------------------
def bot_reply(user_text: str) -> str:
    topic = detect_topic(user_text)
    low = user_text.lower().strip()

    if low in ("/help", "help"):
        return (
            "Commands:\n"
            "- /meme [drake|two|office|brainrot] <text>\n"
            "- /caption <text>\n"
            "- /slang <word>\n"
            "- /hindi <phrase>\n"
            "- /ig trends|reels|content_ideas|seo_keywords|hashtag_guidelines|meme_notes|genz_slang_2026\n"
            "Try: /meme drake about replying ‘on my way’"
        )

    if low.startswith("/ig"):
        arg = user_text[len("/ig"):].strip() or "trends"
        return format_ig_pack(arg)

    if low.startswith("/slang"):
        return slang_lookup(user_text[len("/slang"):])

    if low.startswith("/hindi"):
        return hinglish_lookup(user_text[len("/hindi"):])

    if low.startswith("/caption"):
        return make_caption(user_text[len("/caption"):].strip(), topic)

    if low.startswith("/meme"):
        rest = user_text[len("/meme"):].strip()
        parts = rest.split(maxsplit=1)
        first = parts[0] if parts else ""
        maybe_key = pick_template_key(first)

        if maybe_key:
            core = parts[1] if len(parts) > 1 else ""
            if "faah" in core.lower():
                core2 = re.sub(r"\bfaah\b", "", core, flags=re.I).strip()
                return "FAAH meme (text):\n" + make_faah_meme_text(core2)
            return make_topic_meme(topic, core, template_key=maybe_key)

        core = rest
        if "faah" in core.lower():
            core2 = re.sub(r"\bfaah\b", "", core, flags=re.I).strip()
            return "FAAH meme (text):\n" + make_faah_meme_text(core2)
        return make_topic_meme(topic, core)

    # If user just says "faah ..."
    if "faah" in low:
        core2 = re.sub(r"\bfaah\b", "", user_text, flags=re.I).strip()
        return "FAAH meme (text):\n" + make_faah_meme_text(core2)

    # Default chatty prompt by topic
    openers = {
        "plans": ["Weekend ka scene kya hai?", "Plan drop kar—time lock karo."],
        "relationships": ["Real talk: clarity ya peace?", "Seen zone ka update?"],
        "study": ["30-min sprint? bas start.", "Chai + notes = power-up."],
        "food": ["Craving detected. Momos ya chai?", "Spicy vs regret—choose."],
        "gym": ["Gym arc loading—leg day pe vanish mat."],
        "social": ["Caption chahiye? /caption try kar.", "Reels idea chahiye? /ig reels dekh."],
        "gaming": ["Warm-up then ranked.", "Clean comms = W."],
        "mood": ["Vibe check: 0–10?", "Chill maar—1 small step first."],
        "general": ["Bol, kya scene?", "Give me the lore."],
    }
    s = random.choice(openers.get(topic, openers["general"]))
    if random.random() < 0.22:
        s += " (no cap)"
    return s

# -----------------------------
# UI + state
# -----------------------------
st.title("Gen‑Z Hinglish Meme Bot")
st.caption("Try:  /meme drake about replying ‘on my way’   |   /ig trends   |   /slang aura")

if "messages" not in st.session_state:
    st.session_state.messages = []

with st.sidebar:
    st.subheader("Sound")
    sound_mode = st.radio("Mode", ["Off", "Beep", "FAAH synth"], index=2)
    faah_on_jokes = st.toggle("Play FAAH on jokes/memes", value=True)
    faah_chance = st.slider("FAAH frequency", 0.0, 1.0, 0.6, 0.05)

    st.divider()
    st.subheader("One‑click demos")
    if st.button("Send FAAH meme demo"):
        st.session_state["_queued_input"] = "/meme faah about ordering extra spicy momos"
    if st.button("Send IG trends demo"):
        st.session_state["_queued_input"] = "/ig trends"

    st.divider()
    st.subheader("Examples")
    st.code("/meme drake about replying 'on my way'", language="text")
    st.code("/meme office about 'quick update'", language="text")
    st.code("/caption for my reel: exam week survival", language="text")
    st.code("/slang cooked", language="text")
    st.code("/hindi kya scene", language="text")
    st.code("/ig reels", language="text")

def maybe_play_audio(user_text: str, bot_text: str, blocked: bool = False):
    if sound_mode == "Off":
        return

    if blocked:
        if sound_mode == "Beep":
            st.audio(make_beep_wav(), format="audio/wav")
        return

    should_faah = ("faah" in (user_text or "").lower()) or ("faah" in (bot_text or "").lower())
    if faah_on_jokes and is_jokey(user_text, bot_text) and (random.random() < faah_chance):
        should_faah = True

    if sound_mode == "FAAH synth" and should_faah:
        st.audio(make_faah_synth_wav(), format="audio/wav")
    elif sound_mode == "Beep":
        st.audio(make_beep_wav(), format="audio/wav")

st.markdown('<div class="chat-card">', unsafe_allow_html=True)

for m in st.session_state.messages:
    with st.chat_message(m["role"]):
        st.markdown(m["content"])
        st.markdown(f'<div class="small">{m["ts"]}</div>', unsafe_allow_html=True)

queued = st.session_state.pop("_queued_input", None)
user_text = queued or st.chat_input("Type here… (try: /ig trends)")

st.markdown("</div>", unsafe_allow_html=True)

if user_text:
    ts = dt.datetime.now().strftime("%H:%M")
    st.session_state.messages.append({"role": "user", "content": user_text, "ts": ts})

    if is_blocked(user_text):
        st.session_state.messages.append({"role": "assistant", "content": SAFE_REFUSAL, "ts": ts})
        maybe_play_audio(user_text, SAFE_REFUSAL, blocked=True)
        st.rerun()

    reply = bot_reply(user_text)
    st.session_state.messages.append({"role": "assistant", "content": reply, "ts": ts})
    maybe_play_audio(user_text, reply, blocked=False)
    st.rerun()
