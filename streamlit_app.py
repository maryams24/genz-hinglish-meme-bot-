# Code Generated by Sidekick is for learning and experimentation purposes only.
import base64
import datetime as dt
import io
import math
import random
import re
import wave
from pathlib import Path

import streamlit as st
import streamlit.components.v1 as components

# =============================
# App config
# =============================
st.set_page_config(page_title="FAAH • Roast + Office Bot", layout="centered")
random.seed()


# =============================
# Session state
# =============================
def ss_init():
    if "messages" not in st.session_state:
        st.session_state.messages = []

    if "sound_enabled" not in st.session_state:
        st.session_state.sound_enabled = False

    if "sound_error_once" not in st.session_state:
        st.session_state.sound_error_once = False

    if "_queued_input" not in st.session_state:
        st.session_state._queued_input = None

    if "pending_audio" not in st.session_state:
        st.session_state.pending_audio = None  # dict: {bytes,mime,label,autoplay,nonce}

    if "faah_upload_bytes" not in st.session_state:
        st.session_state.faah_upload_bytes = None
        st.session_state.faah_upload_mime = None
        st.session_state.faah_upload_name = None

    if "audio_nonce" not in st.session_state:
        st.session_state.audio_nonce = 0


ss_init()


# =============================
# UI (dark background + LIGHT surfaces + DARK text)
# =============================
st.markdown(
    """
<style>
/* Code Generated by Sidekick is for learning and experimentation purposes only. */

/* Aesthetic dark background */
.stApp{
  background:
    radial-gradient(1100px 680px at 10% 5%, rgba(0,220,6,0.14), transparent 60%),
    radial-gradient(900px 520px at 92% 8%, rgba(0,169,224,0.18), transparent 62%),
    radial-gradient(900px 560px at 50% 98%, rgba(255,209,0,0.16), transparent 62%),
    radial-gradient(1000px 600px at 70% 70%, rgba(218,41,28,0.10), transparent 60%),
    linear-gradient(180deg, #070A10 0%, #0A1220 55%, #070A10 100%);
}

/* Tokens */
:root{
  --ink:#0B1220;
  --muted:#4B5563;
  --line:rgba(11,18,32,.10);
  --glass:rgba(255,255,255,.90);
  --glass2:rgba(255,255,255,.78);
  --chip:rgba(255,255,255,.70);
  --shadow: 0 12px 40px rgba(0,0,0,.22);
}

/* Layout width */
.block-container{ padding-top: 1.1rem; max-width: 980px; }

/* Hero */
.hero{
  border: 1px solid var(--line);
  background: var(--glass);
  border-radius: 18px;
  padding: 16px 16px 12px 16px;
  box-shadow: var(--shadow);
  backdrop-filter: blur(10px);
}
.title{ font-size: 1.55rem; font-weight: 900; margin:0; color: var(--ink) !important; }
.sub{ margin-top: 6px; font-size: .96rem; color: var(--muted) !important; }
.kbd{
  display:inline-block; padding: 2px 8px; border-radius: 10px;
  border: 1px solid var(--line); background: rgba(255,255,255,.72);
  font-size: .84rem; margin-right: 6px; color: var(--ink) !important;
}
.chips{ display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
.chip{
  border: 1px solid var(--line); background: var(--chip);
  padding: 7px 10px; border-radius: 999px;
  font-size: .86rem; color: var(--muted) !important;
}

/* Card container */
.card{
  margin-top: 12px;
  border: 1px solid var(--line);
  background: var(--glass2);
  border-radius: 18px;
  padding: 12px 12px 6px 12px;
  box-shadow: var(--shadow);
  backdrop-filter: blur(10px);
}
.small{ font-size:.90rem; color: var(--muted) !important; }

/* Force dark readable text in key areas */
.hero *, .card *, section[data-testid="stSidebar"] *{
  color: var(--ink) !important;
}
.hero .sub, .chip, .small, section[data-testid="stSidebar"] .stCaption{
  color: var(--muted) !important;
}

/* Sidebar = light surface */
section[data-testid="stSidebar"]{
  background: rgba(255,255,255,.82) !important;
  border-right: 1px solid var(--line);
  backdrop-filter: blur(10px);
}

/* Chat bubbles: readable */
div[data-testid="stChatMessage"]{
  border: 1px solid var(--line) !important;
  background: rgba(255,255,255,.92) !important;
  border-radius: 16px !important;
  box-shadow: 0 8px 22px rgba(0,0,0,.12);
}
div[data-testid="stChatMessage"] *{
  color: var(--ink) !important;
}

/* Chat input readability */
div[data-testid="stChatInput"]{
  border: 1px solid var(--line) !important;
  border-radius: 14px !important;
  background: rgba(255,255,255,.92) !important;
  box-shadow: 0 10px 28px rgba(0,0,0,.12);
}
div[data-testid="stChatInput"] textarea{
  color: var(--ink) !important;
}

/* Buttons look nicer */
button[kind="primary"], button[kind="secondary"], .stButton button{
  border-radius: 12px !important;
}
</style>
""",
    unsafe_allow_html=True,
)


# =============================
# Safety (keep it clean)
# =============================
BLOCKLIST = {
    "rape", "raping", "porn", "nudes", "blowjob", "handjob", "kys", "kill yourself",
    "nazi", "hitler",
}
SAFE_REFUSAL = "I can’t help with abusive/explicit content. Keep it clean and I’m in."

def is_blocked(text: str) -> bool:
    t = (text or "").lower()
    return any(w in t for w in BLOCKLIST)


# =============================
# Audio (FAAH): upload/assets/synth + autoplay attempt
# =============================
DEFAULT_SOUND_ERROR = "SoundBlockedError: click ‘Enable Sound’ once, then send again."

def _to_wav_bytes(sr: int, samples_f32: list[float]) -> bytes:
    pcm = bytearray()
    for x in samples_f32:
        x = max(-1.0, min(1.0, float(x)))
        i = int(x * 32767.0)
        pcm += int(i).to_bytes(2, "little", signed=True)

    buf = io.BytesIO()
    with wave.open(buf, "wb") as wf:
        wf.setnchannels(1)
        wf.setsampwidth(2)
        wf.setframerate(sr)
        wf.writeframes(bytes(pcm))
    return buf.getvalue()

def make_faah_synth_wav() -> bytes:
    # Down-sweep + noise burst => comedic "FAAH"
    sr, dur = 22050, 0.28
    n = int(sr * dur)
    out = []
    f0, f1 = 720.0, 140.0
    phase = 0.0
    for i in range(n):
        t = i / sr
        freq = f0 * ((f1 / f0) ** (t / dur))  # exponential sweep
        phase += (2.0 * math.pi * freq) / sr
        sweep = math.sin(phase)
        noise = (random.random() * 2.0 - 1.0) * 0.10
        env = math.exp(-8.0 * t)
        out.append(math.tanh(2.3 * (0.90 * sweep + noise)) * env)
    return _to_wav_bytes(sr, out)

def make_beep_wav() -> bytes:
    sr, dur = 22050, 0.10
    n = int(sr * dur)
    out = []
    for i in range(n):
        t = i / sr
        env = math.exp(-10.0 * t)
        out.append(0.18 * math.sin(2.0 * math.pi * 880.0 * t) * env)
    return _to_wav_bytes(sr, out)

def load_assets_faah() -> tuple[bytes | None, str | None, str | None]:
    candidates = [
        (Path("assets/faah.mp3"), "audio/mpeg"),
        (Path("assets/faah.wav"), "audio/wav"),
    ]
    for p, mime in candidates:
        if p.exists() and p.is_file():
            return p.read_bytes(), mime, str(p)
    return None, None, None

ASSET_BYTES, ASSET_MIME, ASSET_PATH = load_assets_faah()

def get_faah_bytes(sound_mode: str) -> tuple[bytes, str, str]:
    if sound_mode == "FAAH (uploaded)" and st.session_state.faah_upload_bytes:
        return (
            st.session_state.faah_upload_bytes,
            st.session_state.faah_upload_mime or "audio/mpeg",
            "FAAH (uploaded)",
        )
    if sound_mode == "FAAH (assets)" and ASSET_BYTES:
        return (
            ASSET_BYTES,
            ASSET_MIME or "audio/mpeg",
            f"FAAH (assets: {ASSET_PATH})",
        )
    return (make_faah_synth_wav(), "audio/wav", "FAAH (synth)")

def queue_audio(bytes_data: bytes, mime: str, label: str, autoplay: bool):
    st.session_state.audio_nonce += 1
    st.session_state.pending_audio = {
        "bytes": bytes_data,
        "mime": mime,
        "label": label,
        "autoplay": autoplay,
        "nonce": st.session_state.audio_nonce,
    }

def render_autoplay_audio(audio_bytes: bytes, mime: str, nonce: int):
    # Best-effort autoplay; may still be blocked by browser policy
    b64 = base64.b64encode(audio_bytes).decode("ascii")
    html = f"""
    <audio id="faah{nonce}" autoplay>
      <source src="data:{mime};base64,{b64}" type="{mime}">
    </audio>
    <script>
      (function(){{
        const el = document.getElementById("faah{nonce}");
        if(!el) return;
        const p = el.play();
        if(p && p.catch) p.catch(()=>{{}});
      }})();
    </script>
    """
    components.html(html, height=0, width=0)


# =============================
# Bot personality + memes
# =============================
VIBE_PRESETS = {
    "Office": {"roast": 0, "talk": 0.45, "hinglish": 0.00, "filmy": 0.00},
    "Bestie": {"roast": 2, "talk": 0.75, "hinglish": 0.55, "filmy": 0.25},
    "Filmy":  {"roast": 3, "talk": 0.80, "hinglish": 0.65, "filmy": 0.85},
    "Savage": {"roast": 7, "talk": 0.70, "hinglish": 0.45, "filmy": 0.15},
}

OPENERS = [
    "Okay, listen.", "Haan bolo.", "Give me the full context.", "Noted—slightly suspicious.",
    "I’m here. Continue.",
]
TAGS = [
    "*dramatic zoom-in*", "*group chat typing noises*", "*slow clap, fast judgment*",
    "*tension bgm on*",
]
HINGLISH = ["bhai", "yaar", "scene", "set", "pakka", "chill", "bas", "matlab"]

ROAST_LIGHT = [
    "That plan has more versions than your excuses.",
    "‘On my way’ is your brand identity, huh?",
    "Confidence 10/10. Execution… we’ll talk.",
]
ROAST_SAVAGE = [
    "Your punctuality is a myth—like unicorns, but louder.",
    "Consistency? Yes—at vanishing right on time.",
    "Discipline left the chat and blocked you.",
]

FOLLOWUP_FUN = [
    "One detail: who started it?",
    "Scale 1–10, how cooked are we?",
    "What exact line did they say?",
    "Time, place, and villain—go.",
]
FOLLOWUP_OFFICE = [
    "What’s the desired outcome?",
    "Any deadlines or constraints?",
    "Who’s the key stakeholder?",
]

SUGGESTIONS = [
    "Want a POV meme? Type: /meme pov <line>",
    "Want Bollywood drama? Type: /meme bolly <line>",
    "Want a caption? Type: /caption <line>",
    "Want prompt ideas? Type: /ig prompts",
    "Want FAAH sound? Type: /faah",
]

BOLLY_STYLES = [
    "Overacting level: 100",
    "Dialogues mode: ON, logic: OFF",
    "Slow zoom reaction + ‘abey yaar’",
    "Auntie network breaking news vibe",
]

MEME_FORMATS = {
    "pov": [
        "POV: {setup}\nOn-screen text: “why am I like this”\nCut to: {payoff}",
        "POV: {setup}\nMe (internally): “chill”\nAlso me: {payoff}",
    ],
    "microdrama": [
        "Hook: {setup}\nTwist: {payoff}\nCTA: “comment your version”",
        "Hook: {setup}\nEscalation: {payoff}\nCTA: “send this to your friend”",
    ],
    "invsout": [
        "IN: {setup}\nOUT: {payoff}",
        "IN: {setup}\nOUT: {payoff}\nNo cap.",
    ],
    "thisvsthat": [
        "This: {setup}\nThat: {payoff}",
        "{setup} vs {payoff}\nChoose your fighter.",
    ],
    "greenscreen": [
        "Green screen: {setup}\nMe: “let’s unpack this”\nAlso me: {payoff}",
        "Green screen: {setup}\nMy face says it all.\n{payoff}",
    ],
    "capcut": [
        "CapCut-template vibes:\nClip 1: {setup}\nBeat drop: {payoff}\nEnd: “save for later”",
        "Fast cuts + on-beat text:\n{setup}\n{payoff}\nLoop it.",
    ],
    "aitokyo": [
        "AI scene replace:\nSwap main character with: {setup}\nPlot twist: {payoff}",
        "Replace the ‘hero’ with: {setup}\nReplace the ‘twist’ with: {payoff}",
    ],
    "bolly": [
        "Bollywood energy: {style}\nScene: {setup}\nReaction: {payoff}",
        "Filmy zoom-in:\n{style}\n{setup}\n{payoff}",
    ],
}

TOPIC_FILLERS = {
    "work": (
        ["Client: “small change”", "Manager: “quick update?”", "Calendar: 9 calls back-to-back"],
        ["Deadline jump-scare", "PPT became my personality", "My soul left the call"],
    ),
    "social": (
        ["Soft launch plan", "Caption: “simple sa”", "Story: “lowkey”"],
        ["17 drafts later", "Delete → repost cycle", "Close friends chaos"],
    ),
    "study": (
        ["“Bas 20 mins padhai”", "Exam tomorrow confidence", "Notes open, motivation closed"],
        ["3 tabs, 0 pages", "All-nighter delulu", "Aesthetic notes, tragic marks"],
    ),
    "food": (
        ["“Bas ek bite”", "Extra spicy choice", "Food app: “just browsing”"],
        ["Extra cheese regret", "UPI pin speedrun", "Instant consequences"],
    ),
    "general": (
        ["Main character moment", "“Bas ek kaam”", "Life ka plan"],
        ["Plot twist unlocked", "Aura points -10", "Chalta hai cope mode"],
    ),
}

def detect_topic(text: str) -> str:
    t = (text or "").lower()
    if any(w in t for w in ["client", "manager", "meeting", "deadline", "ppt", "deck", "standup", "call"]):
        return "work"
    if any(w in t for w in ["reel", "reels", "instagram", "ig", "story", "post", "caption"]):
        return "social"
    if any(w in t for w in ["exam", "study", "college", "class", "assignment"]):
        return "study"
    if any(w in t for w in ["momos", "chai", "coffee", "pizza", "spicy", "food"]):
        return "food"
    return "general"

def pick_setup_payoff(topic: str, core: str) -> tuple[str, str]:
    topic = topic if topic in TOPIC_FILLERS else "general"
    setups, payoffs = TOPIC_FILLERS[topic]
    setup = re.sub(r"\s+", " ", (core or "")).strip() or random.choice(setups)
    payoff = random.choice(payoffs)
    return setup, payoff

def make_meme(fmt: str, core: str) -> str:
    topic = detect_topic(core)
    setup, payoff = pick_setup_payoff(topic, core)
    fmt = (fmt or "pov").lower().strip()
    if fmt not in MEME_FORMATS:
        fmt = "pov"
    template = random.choice(MEME_FORMATS[fmt])
    if fmt == "bolly":
        return template.format(style=random.choice(BOLLY_STYLES), setup=setup, payoff=payoff)
    return template.format(setup=setup, payoff=payoff)

def make_caption(core: str) -> str:
    topic = detect_topic(core)
    hooks = ["POV:", "Me:", "Lowkey", "Highkey", "Normalize", "It’s giving"]
    specifics = ["at 2:13am", "with 3% battery", "after one chai", "during exam week", "in the group chat"]
    cta = ["Real or nah.", "IYKYK.", "Be honest.", "Tell me I’m not alone."]
    core = re.sub(r"\s+", " ", (core or "")).strip() or "this whole situation"
    core = core[:120]
    tags = {
        "work": "#workmemes #officehumor #consultinglife",
        "social": "#reels #memes #captionideas",
        "study": "#studentlife #examseason #studygram",
        "food": "#foodie #snacktime #streetfood",
        "general": "#relatable #memes #vibes",
    }[topic]
    return f"{random.choice(hooks)} {core} {random.choice(specifics)} {random.choice(cta)}\n{tags}"

IG_PROMPTS = (
    "Copy‑paste prompts:\n"
    "- /meme pov I said ‘on my way’\n"
    "- /meme microdrama client said ‘small change’\n"
    "- /meme invsout college life\n"
    "- /meme thisvsthat gym vs sleep\n"
    "- /meme greenscreen group chat drama\n"
    "- /meme capcut weekend recap\n"
    "- /meme aitokyo meeting reschedule\n"
    "- /meme bolly when chai finishes\n"
    "- /caption exam week survival\n"
    "- /faah\n"
)

def sprinkle_hinglish(text: str, ratio: float) -> str:
    if ratio <= 0:
        return text
    if random.random() < ratio:
        text = f"{random.choice(HINGLISH)} — {text}"
    if random.random() < ratio * 0.55:
        text = f"{text} ({random.choice(HINGLISH)})"
    return text

def pick_roast(roast_level: int) -> str:
    if roast_level <= 0:
        return ""
    pool = ROAST_LIGHT if roast_level <= 4 else ROAST_SAVAGE
    return random.choice(pool)

def make_talkative_reply(
    base_reply: str,
    user_text: str,
    *,
    office_mode: bool,
    allow_roasts: bool,
    force_roast: bool,
    roast_level: int,
    talk: float,
    hinglish: float,
    filmy: float,
) -> tuple[str, bool]:
    low = (user_text or "").strip().lower()

    # Don’t overtalk pure reference commands
    if low.startswith(("/help", "/ig")):
        return base_reply, False

    parts = []
    used_roast = False

    if random.random() < talk:
        parts.append(random.choice(OPENERS))

    tag_prob = 0.06 if office_mode else (0.22 + 0.55 * filmy)
    if random.random() < tag_prob:
        parts.append(random.choice(TAGS))

    if allow_roasts and (not office_mode) and roast_level > 0:
        if force_roast or (random.random() < (0.26 + 0.07 * roast_level)):
            r = pick_roast(roast_level)
            if r:
                parts.append(r)
                used_roast = True

    parts.append(base_reply)

    if random.random() < (0.28 + 0.45 * talk):
        parts.append(random.choice(FOLLOWUP_OFFICE if office_mode else FOLLOWUP_FUN))

    if random.random() < (0.55 if office_mode else 0.85):
        parts.append(random.choice(SUGGESTIONS))

    out = "\n".join([p for p in parts if p])
    out = sprinkle_hinglish(out, 0.0 if office_mode else hinglish)
    return out, used_roast


# =============================
# Office-level conversation
# =============================
def office_reply(user_text: str) -> str:
    t = (user_text or "").strip()
    low = t.lower()

    if any(k in low for k in ["standup", "status update", "status", "daily update"]):
        return (
            "Share three bullets: Done / Next / Blockers. "
            "If you paste your draft, I’ll tighten wording and make it crisp."
        )

    if any(k in low for k in ["email", "mail", "slack", "teams", "message"]):
        return "Tell me: audience + ask + deadline + tone. I’ll draft it."

    if any(k in low for k in ["agenda", "meeting notes", "minutes", "mom"]):
        return "What’s the meeting goal and attendees? I’ll format an agenda or notes template."

    if any(k in low for k in ["apology", "sorry", "late"]):
        return "Who are you messaging, and what’s the new ETA? I’ll draft a clean apology + next steps."

    if any(k in low for k in ["ppt", "deck", "slides"]):
        return "What’s the audience and decision needed? I can propose a 6-slide storyline."

    if any(k in low for k in ["risk", "issue", "blocker"]):
        return "Describe impact, likelihood, and mitigation. I’ll turn it into a tight RAID entry."

    return "Understood. What’s the desired outcome, constraint, and next decision?"


# =============================
# Commands router
# =============================
def bot_reply(user_text: str) -> tuple[str, bool]:
    """
    returns (reply_text, must_play_faah_explicit)
    Explicit FAAH sound only via /faah (roast sound handled elsewhere).
    """
    t = (user_text or "").strip()
    low = t.lower()

    if low in ("/help", "help"):
        return (
            "Commands:\n"
            "- /faah  (play FAAH)\n"
            "- /meme <pov|microdrama|invsout|thisvsthat|greenscreen|capcut|aitokyo|bolly> <text>\n"
            "- /caption <text>\n"
            "- /ig prompts\n\n"
            "Try:\n"
            "- roast me\n"
            "- help me write a standup update\n"
            "- /meme microdrama client said small change\n",
            False,
        )

    if low.startswith("/ig"):
        return (IG_PROMPTS, False)

    if low.startswith("/caption"):
        core = t[len("/caption"):].strip()
        return (make_caption(core), False)

    if low.startswith("/meme"):
        rest = t[len("/meme"):].strip()
        parts = rest.split(maxsplit=1)
        fmt = parts[0].lower() if parts else "pov"
        core = parts[1] if len(parts) > 1 else ""
        return (make_meme(fmt, core), False)

    if low.startswith("/faah"):
        return ("FAAH. (If it didn’t autoplay, click play.)", True)

    return ("", False)


# =============================
# Sidebar controls
# =============================
with st.sidebar:
    st.subheader("Bot")
    vibe = st.selectbox("Personality", list(VIBE_PRESETS.keys()), index=0)
    preset = VIBE_PRESETS[vibe]

    office_mode = st.toggle("Office mode (professional replies)", value=(vibe == "Office"))
    allow_roasts = st.toggle("Allow roasts (FAAH on roast)", value=(vibe in ("Bestie", "Filmy", "Savage")) and not office_mode)

    talk = st.slider("Talkativeness", 0.0, 1.0, float(preset["talk"]), 0.05)
    roast_level = st.slider("Roast level", 0, 10, int(preset["roast"]), 1)
    hinglish = st.slider("Hinglish mix", 0.0, 1.0, float(preset["hinglish"]), 0.05)
    filmy = st.slider("Filmy drama", 0.0, 1.0, float(preset["filmy"]), 0.05)

    st.divider()
    st.subheader("Sound (FAAH)")
    sound_mode = st.radio("FAAH source", ["Off", "FAAH (uploaded)", "FAAH (assets)", "FAAH (synth)"], index=3)
    attempt_autoplay = st.toggle("Attempt autoplay", value=True)
    error_text = st.text_input("One-time sound error text", value=DEFAULT_SOUND_ERROR)

    c1, c2 = st.columns(2)
    with c1:
        if st.button("Enable Sound (click once)"):
            st.session_state.sound_enabled = True
            st.success("Sound enabled (autoplay will be attempted).")
    with c2:
        if st.button("Reset sound error"):
            st.session_state.sound_error_once = False
            st.info("Sound error will show once again.")

    if sound_mode == "FAAH (uploaded)":
        up = st.file_uploader("Upload faah.mp3 or faah.wav", type=["mp3", "wav"])
        if up is not None:
            st.session_state.faah_upload_bytes = up.getvalue()
            st.session_state.faah_upload_name = up.name
            st.session_state.faah_upload_mime = up.type or ("audio/mpeg" if up.name.lower().endswith(".mp3") else "audio/wav")
        if st.session_state.faah_upload_name:
            st.caption(f"Loaded: {st.session_state.faah_upload_name}")

    if sound_mode == "FAAH (assets)":
        if ASSET_BYTES:
            st.caption(f"Loaded: {ASSET_PATH}")
        else:
            st.caption("Tip: add assets/faah.mp3 for a custom sound.")

    st.divider()
    st.subheader("Quick buttons")
    if st.button("Roast me (plays FAAH)"):
        st.session_state._queued_input = "roast me for being late again"
    if st.button("Office: standup update"):
        st.session_state._queued_input = "help me write a standup update"
    if st.button("Meme: client ‘small change’"):
        st.session_state._queued_input = "/meme microdrama client said small change"
    if st.button("IG prompts"):
        st.session_state._queued_input = "/ig prompts"
    if st.button("Play FAAH now"):
        st.session_state._queued_input = "/faah"


# =============================
# Header
# =============================
st.markdown(
    """
<div class="hero">
  <div class="title">FAAH • Roast Bot + Office Mode</div>
  <div class="sub">
    <span class="kbd">roast me</span>
    <span class="kbd">/meme</span>
    <span class="kbd">/caption</span>
    <span class="kbd">/ig prompts</span>
    <span class="kbd">/faah</span>
    <span class="kbd">/help</span>
  </div>
  <div class="chips">
    <div class="chip">Dark background, readable dark text</div>
    <div class="chip">FAAH plays only on roasts + /faah</div>
    <div class="chip">Office mode = normal work conversation</div>
  </div>
</div>
""",
    unsafe_allow_html=True,
)

# =============================
# Audio render
# =============================
if st.session_state.pending_audio is not None:
    p = st.session_state.pending_audio
    st.caption(p["label"])

    if attempt_autoplay and p["autoplay"] and st.session_state.sound_enabled:
        render_autoplay_audio(p["bytes"], p["mime"], p["nonce"])

    st.audio(p["bytes"], format=p["mime"])
    st.session_state.pending_audio = None


# =============================
# Chat UI
# =============================
st.markdown('<div class="card">', unsafe_allow_html=True)
st.markdown('<div class="small">Type anything. Use Office mode for professional help. Type “roast me” for fun (FAAH plays).</div>', unsafe_allow_html=True)

for m in st.session_state.messages:
    with st.chat_message(m["role"]):
        st.markdown(m["content"])
        st.markdown(f'<div class="small">{m["ts"]}</div>', unsafe_allow_html=True)

queued = st.session_state._queued_input
if queued:
    st.session_state._queued_input = None

user_text = queued or st.chat_input("Type here…")
st.markdown("</div>", unsafe_allow_html=True)


# =============================
# Handle message
# =============================
if user_text:
    ts = dt.datetime.now().strftime("%H:%M")
    st.session_state.messages.append({"role": "user", "content": user_text, "ts": ts})

    if is_blocked(user_text):
        st.session_state.messages.append({"role": "assistant", "content": SAFE_REFUSAL, "ts": ts})
        queue_audio(make_beep_wav(), "audio/wav", label="Beep", autoplay=False)
        st.rerun()

    # Commands
    reply, must_play_faah_explicit = bot_reply(user_text)

    # Non-command default behavior
    if not reply:
        if office_mode:
            reply = office_reply(user_text)
        else:
            # Fun conversational baseline
            low = user_text.lower()
            if any(k in low for k in ["meme", "reel", "caption"]):
                reply = "Say less. POV, bolly, microdrama, or greenscreen?"
            elif detect_topic(user_text) == "work":
                reply = "Work chaos detected. Drop the exact line they said."
            else:
                reply = "Okay. Give me the one-liner version—then I’ll cook."

    # Force roast if user asks for it (only in fun mode)
    force_roast = (not office_mode) and bool(re.search(r"\broast( me)?\b", user_text.lower()))

    full_reply, used_roast = make_talkative_reply(
        reply,
        user_text,
        office_mode=office_mode,
        allow_roasts=allow_roasts,
        force_roast=force_roast,
        roast_level=roast_level,
        talk=talk,
        hinglish=hinglish,
        filmy=filmy,
    )

    # Decide sound: ONLY for roasts + /faah
    should_play_sound = False
    if sound_mode != "Off":
        if must_play_faah_explicit:
            should_play_sound = True
        elif used_roast:
            should_play_sound = True

    if should_play_sound and sound_mode != "Off":
        if attempt_autoplay and (not st.session_state.sound_enabled) and (not st.session_state.sound_error_once):
            st.session_state.sound_error_once = True
            st.error(error_text or DEFAULT_SOUND_ERROR)

        b, m, label = get_faah_bytes(sound_mode)
        queue_audio(b, m, label=label, autoplay=attempt_autoplay)

    st.session_state.messages.append({"role": "assistant", "content": full_reply, "ts": ts})
    st.rerun()
